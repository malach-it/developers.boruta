"use strict";(self.webpackChunkdevelopers_boruta=self.webpackChunkdevelopers_boruta||[]).push([[2097],{15680:(e,t,r)=>{r.d(t,{xA:()=>c,yg:()=>h});var n=r(96540);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(r),d=i,h=u["".concat(l,".").concat(d)]||u[d]||g[d]||a;return r?n.createElement(h,o(o({ref:t},c),{},{components:r})):n.createElement(h,o({ref:t},c))}));function h(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<a;p++)o[p]=r[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},61896:(e,t,r)=>{r.d(t,{A:()=>n});const n=r.p+"assets/images/oauth-clients-security-53a48d24dd2781b63f204aeb7c4e0409.png"},96186:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>g,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var n=r(58168),i=(r(96540),r(15680));const a={},o="Clients configuration | Security",s={unversionedId:"provider-configuration/clients/security",id:"provider-configuration/clients/security",title:"Clients configuration | Security",description:"Client attributes help to manage the authorization capabilities for OAuth 2.0 and satellites flows. They provide a high level of customization helping the server to be integrated within infrastructures seamlessly. Those configuration help the flows to be both business and technically adapted for the addressed use case.",source:"@site/docs/provider-configuration/clients/security.md",sourceDirName:"provider-configuration/clients",slug:"/provider-configuration/clients/security",permalink:"/developers.boruta/docs/provider-configuration/clients/security",draft:!1,editUrl:"https://github.com/malach-it/developers.boruta/tree/master/docs/provider-configuration/clients/security.md",tags:[],version:"current",frontMatter:{},sidebar:"borutaSidebar",previous:{title:"Clients configuration | Authentication",permalink:"/developers.boruta/docs/provider-configuration/clients/authentication"},next:{title:"Clients configuration | Grant types",permalink:"/developers.boruta/docs/provider-configuration/clients/grant-types"}},l={},p=[{value:"Cryptographic Signatures",id:"cryptographic-signatures",level:2},{value:"Security parameters",id:"security-parameters",level:2},{value:"Authorization",id:"authorization",level:3},{value:"Proof Key for Code Exchange",id:"proof-key-for-code-exchange",level:3},{value:"User interface",id:"user-interface",level:2}],c={toc:p},u="wrapper";function g(e){let{components:t,...a}=e;return(0,i.yg)(u,(0,n.A)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"clients-configuration--security"},"Clients configuration | Security"),(0,i.yg)("p",null,"Client attributes help to ",(0,i.yg)("strong",{parentName:"p"},"manage the authorization capabilities for OAuth 2.0 and satellites flows"),". They provide a high level of customization helping the server to be integrated within infrastructures seamlessly. Those configuration help the flows to be both business and technically adapted for the addressed use case."),(0,i.yg)("admonition",{title:"Parameters sections",type:"note"},(0,i.yg)("p",{parentName:"admonition"},(0,i.yg)("a",{parentName:"p",href:"/docs/provider-configuration/configure-clients"},"OAuth clients")," can be customized through either the ",(0,i.yg)("a",{parentName:"p",href:"/api/list-clients"},"Administration API")," or the user interface providing 4 ",(0,i.yg)("strong",{parentName:"p"},"categories of settings"),":"),(0,i.yg)("ul",{parentName:"admonition"},(0,i.yg)("li",{parentName:"ul"},"General configuration"),(0,i.yg)("li",{parentName:"ul"},"Authentication"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Security")),(0,i.yg)("li",{parentName:"ul"},"Grant types"))),(0,i.yg)("h2",{id:"cryptographic-signatures"},"Cryptographic Signatures"),(0,i.yg)("p",null,"boruta gives means to ",(0,i.yg)("strong",{parentName:"p"},"implement and connect signature adapters")," which provide means for signing the authorization artifacts both from the federated identity (ID Tokens) and the decentralized identity (Verifiable Credentials). ",(0,i.yg)("strong",{parentName:"p"},"Out of the box"),", an internal (boruta provided) and an Universal adapter are implemented and ready to use. Those support cryptographic material generation and use along side with Decentralized IDentifiers support. Public and Private Keys are the ",(0,i.yg)("strong",{parentName:"p"},"base for enabling signatures")," and the public part of the keys is exposed through the jwks OpenID endpoint. Those keys will be used for the signature of ID Tokens, Userinfo (if needed) and Verifiable Credentials. This enables to connect boruta to ",(0,i.yg)("strong",{parentName:"p"},"Hardware Security Modules (HSM)")," with low effort, enabling them to store cryptographic keys in a secure enclave."),(0,i.yg)("admonition",{title:"Key pair types",type:"note"},(0,i.yg)("p",{parentName:"admonition"},"The type of the generated key pairs is tied to the signature algorithm used for JWTs signature:"),(0,i.yg)("ul",{parentName:"admonition"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"RSA keys")," enforce the JWTs signature algorithm to be of the ",(0,i.yg)("inlineCode",{parentName:"li"},"RS")," algorithm class"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Elliptic curve keys")," enforce the JWTs signature algorithm to be of the ",(0,i.yg)("inlineCode",{parentName:"li"},"ES")," algorithm class"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Universal keys")," enforce the JWTs signature algorithm to be of the ",(0,i.yg)("inlineCode",{parentName:"li"},"EdDSA")," algorithm class"))),(0,i.yg)("h2",{id:"security-parameters"},"Security parameters"),(0,i.yg)("div",{class:"parameters"},(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"ID token signature algorithm")," is the algorithm used to sign ID Token JWTs. It have to be in correspondance with the key pair type."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Userinfo response signature algorithm")," is the algorithm used to sign userinfo response JWTs, the response being possibily not encoded and signed. It have to be in correspondance with the key pair type."),(0,i.yg)("h3",{id:"authorization"},"Authorization"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Enforce Demonstration Proof-of-Possession (DPoP)")," enables the client to only support ",(0,i.yg)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/html/rfc9449"},"DPoP")," requests."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Enforce pre-authorized code transaction code")," enforces the presentation of a ",(0,i.yg)("inlineCode",{parentName:"p"},"tx_code")," while issuing verifiable credentials."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Authorize scope")," would determine if the client defines the specific public and private scopes to be authorized."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Authorized scopes")," would be the list of scopes that can be granted with this client."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Check public client id")," enforces the check of the presentation ",(0,i.yg)("inlineCode",{parentName:"p"},"vp_token")," against the ",(0,i.yg)("inlineCode",{parentName:"p"},"client_id")," parameter in OpenID 4 Verifiable Presentations flows."),(0,i.yg)("h3",{id:"proof-key-for-code-exchange"},"Proof Key for Code Exchange"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"PKCE")," would determine if ",(0,i.yg)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/html/rfc7636"},"Proof Key for Code Exchange")," flow is enforced using this client."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Public refresh token")," allow refreshing tokens without providing a ",(0,i.yg)("inlineCode",{parentName:"p"},"client_secret")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Public revoke")," allow to revoke tokens without providing a ",(0,i.yg)("inlineCode",{parentName:"p"},"client_secret"))),(0,i.yg)("h2",{id:"user-interface"},"User interface"),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"client form",src:r(61896).A,width:"1257",height:"1307"})))}g.isMDXComponent=!0}}]);