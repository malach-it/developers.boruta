"use strict";(self.webpackChunkdevelopers_boruta=self.webpackChunkdevelopers_boruta||[]).push([[2126],{15680:(e,t,a)=>{a.d(t,{xA:()=>h,yg:()=>p});var i=a(96540);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function n(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,i)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?n(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,i,s=function(e,t){if(null==e)return{};var a,i,s={},n=Object.keys(e);for(i=0;i<n.length;i++)a=n[i],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(i=0;i<n.length;i++)a=n[i],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var l=i.createContext({}),u=function(e){var t=i.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},h=function(e){var t=u(e.components);return i.createElement(l.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var a=e.components,s=e.mdxType,n=e.originalType,l=e.parentName,h=r(e,["components","mdxType","originalType","parentName"]),c=u(a),m=s,p=c["".concat(l,".").concat(m)]||c[m]||d[m]||n;return a?i.createElement(p,o(o({ref:t},h),{},{components:a})):i.createElement(p,o({ref:t},h))}));function p(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var n=a.length,o=new Array(n);o[0]=m;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[c]="string"==typeof e?e:s,o[1]=r;for(var u=2;u<n;u++)o[u]=a[u];return i.createElement.apply(null,o)}return i.createElement.apply(null,a)}m.displayName="MDXCreateElement"},78586:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>n,metadata:()=>r,toc:()=>u});var i=a(58168),s=(a(96540),a(15680));const n={},o="Verifiable Credentials Decentralized Status",r={unversionedId:"drafts/vc-decentralized-status",id:"drafts/vc-decentralized-status",title:"Verifiable Credentials Decentralized Status",description:"Abstract",source:"@site/docs/drafts/vc-decentralized-status.md",sourceDirName:"drafts",slug:"/drafts/vc-decentralized-status",permalink:"/developers.boruta/docs/drafts/vc-decentralized-status",draft:!1,editUrl:"https://github.com/malach-it/developers.boruta/tree/master/docs/drafts/vc-decentralized-status.md",tags:[],version:"current",frontMatter:{},sidebar:"borutaSidebar",previous:{title:"Upstreams configuration",permalink:"/developers.boruta/docs/provider-configuration/configure-upstreams"}},l={},u=[{value:"Abstract",id:"abstract",level:2},{value:"Status of the document",id:"status-of-the-document",level:2},{value:"Motivation",id:"motivation",level:2},{value:"1. Introduction",id:"1-introduction",level:2},{value:"1. Specifications",id:"1-specifications",level:3},{value:"2. Data Model",id:"2-data-model",level:2},{value:"2.1 Status Tokens",id:"21-status-tokens",level:3},{value:"2.2 Example",id:"22-example",level:4},{value:"2.2 Status information",id:"22-status-information",level:3},{value:"2.1 Derived Status",id:"21-derived-status",level:3},{value:"4. Implementation",id:"4-implementation",level:2},{value:"4.1 Crafting a verifiable credential status token",id:"41-crafting-a-verifiable-credential-status-token",level:3},{value:"4.2 Resolving a verifiable credential status token",id:"42-resolving-a-verifiable-credential-status-token",level:3},{value:"4.3 Example implementation",id:"43-example-implementation",level:3},{value:"5. Privacy Considerations",id:"5-privacy-considerations",level:2},{value:"5.1 Decentralized Architecture",id:"51-decentralized-architecture",level:3},{value:"5.2 Status table",id:"52-status-table",level:3},{value:"5.3 Granularity",id:"53-granularity",level:3},{value:"5.4 Annotation",id:"54-annotation",level:3},{value:"5.5 Issuer trust",id:"55-issuer-trust",level:3},{value:"6. About revocation",id:"6-about-revocation",level:2},{value:"7. Going further, status chains",id:"7-going-further-status-chains",level:2},{value:"7.1 Choosing a status among the chain",id:"71-choosing-a-status-among-the-chain",level:3},{value:"7.2 Public statuses",id:"72-public-statuses",level:3},{value:"7.3 Choosing multiple statuses",id:"73-choosing-multiple-statuses",level:3}],h={toc:u},c="wrapper";function d(e){let{components:t,...a}=e;return(0,s.yg)(c,(0,i.A)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,s.yg)("h1",{id:"verifiable-credentials-decentralized-status"},"Verifiable Credentials Decentralized Status"),(0,s.yg)("h2",{id:"abstract"},"Abstract"),(0,s.yg)("p",null,"Credentials give information about a subject that helps in its recognition by a third party, usually to provide a service or state an assertion given its traits. The verification of credentials needs additional information to assert the validity of the information contained in it. This specification provides a way to store verifiable credential status and verify it in a decentralized context. The architecture enables the verifiable credential holders to store derived status information that can only be resolved by the issuer without prior centralized storage."),(0,s.yg)("h2",{id:"status-of-the-document"},"Status of the document"),(0,s.yg)("p",null,"This document is a working draft of a possible specification."),(0,s.yg)("h2",{id:"motivation"},"Motivation"),(0,s.yg)("p",null,"As stated the status adds information to verifiable credentials to assert credential validity. That piece of information annotates data, the closer it is to the actual information it denotes, the less there are possibilities of uncoupling of the data and its status. Providing a way to store both information at the same place gives a way to provide that proximity. The decentralized way of seeing status storage differ from actual status list specifications since it requires no centralized storage for statuses which makes them faster to resolve and then better scales with the projected number of emitted verifiable credentials. It also makes other tradeoffs about privacy (see 6. Privacy considerations) staying reasonable with those concerns. This specification is open to contributions to better solve the status issue deepening further the work on revocation which is still ongoing."),(0,s.yg)("h2",{id:"1-introduction"},"1. Introduction"),(0,s.yg)("h3",{id:"1-specifications"},"1. Specifications"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},"HOTP")),(0,s.yg)("h2",{id:"2-data-model"},"2. Data Model"),(0,s.yg)("h3",{id:"21-status-tokens"},"2.1 Status Tokens"),(0,s.yg)("p",null,"Status tokens are the major components of this specification. They enable holders to store the status information without disclosing it, making the status only resolvable by the issuer. Those tokens are made of two parts: the first contains encoded information that helps resolve the second part. The latter contains a status cryptographic derivation."),(0,s.yg)("p",null,(0,s.yg)("img",{parentName:"p",src:"https://raw.githubusercontent.com/malach-it/vc-decentralized-status/main/images/sotp.png",alt:"token anatomy"})),(0,s.yg)("h4",{id:"22-example"},"2.2 Example"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre"},"BiwBG3EYQhLDjAMA~2f0f96b9\n")),(0,s.yg)("h3",{id:"22-status-information"},"2.2 Status information"),(0,s.yg)("p",null,"The status information, as the first part of status tokens, is encoded to store a low-weighted payload that contains the iat and the status token time to live. It helps to resolve the status contained in the derived token. Not being part of token verification algorithm, this part contains information about when the token was issued. The contained information is stored in a binary format and URL-safe base 64 encoded."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre"},"<iat>{4}<binary encode Time To Live>{4}\n")),(0,s.yg)("p",null,"The iat may be 7 bytes long and binary encoded. The time to live may also be padded binary encoded integer to save storage. Those parts may be concatenated to form the status information."),(0,s.yg)("h3",{id:"21-derived-status"},"2.1 Derived Status"),(0,s.yg)("p",null,(0,s.yg)("img",{parentName:"p",src:"https://raw.githubusercontent.com/malach-it/vc-decentralized-status/main/images/non-opaque-salt.png",alt:"Status derivation"})),(0,s.yg)("p",null,"Using the HOTP algorithm with a secret kept by the issuer and a counter made of Unix timestamp and status shift, we can derive the status but keep also the expiry information in the same token. Noticing that the shift preserves the validity range size, the next checks within the expiration time will succeed by providing the same shift. Also, the more you take HOTP HMAC value bytes, the more the token will fail to collide improving the entropy of the derivation."),(0,s.yg)("h2",{id:"4-implementation"},"4. Implementation"),(0,s.yg)("h3",{id:"41-crafting-a-verifiable-credential-status-token"},"4.1 Crafting a verifiable credential status token"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre"},'@status_table = [ status: string ]\nshift(status: string): int {\n  BINARY_DECODE_UNSIGNED(status)\n}\n\ngenerate_status_token(secret: string, ttl: int, status: string): int {\n  iat = BINARY_ENCODE(NOW(:microsecond)) # 7 bytes long\n  time_to_live = PAD_LEFT(BINARY_ENCODE(ttl), 4) # 4 bytes long\n\n  token_info = BASE64_ENCODE(iat + time_to_live)\n  derived_status = HTOP(secret, DIV(NOW(:second), ttl) + shift(status))\n\n  return "<token_info>~<derived_status>"\n}\n')),(0,s.yg)("h3",{id:"42-resolving-a-verifiable-credential-status-token"},"4.2 Resolving a verifiable credential status token"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre"},"@status_table = [ status: string ]\nshift(status: string): int {\n  BINARY_DECODE_UNSIGNED(BINARY_ENCODE(status))\n}\n\ndecode_token_info(token_info: string): hashtable {\n  result = REDUCE(\n      BYTES(token_info),\n      { iat => 0, ttl => 0, memory => [] },\n      lambda (byte, index), acc:\n      CASE index\n      WHEN index == 7\n        PUSH(acc[memory], byte)\n        acc[iat] = BINARY_DECODE(acc[memory])\n        RESET(acc[memory])\n        return acc\n      WHEN index == 10\n        PUSH(acc[memory], byte)\n        acc[ttl] = BINARY_DECODE(acc[memory])\n        RESET(acc[memory])\n        return acc\n      ELSE\n        PUSH(acc[memory], byte)\n        return acc\n  )\n  DELETE result[memory]\n  return result\n}\n\nresolve_status_token(secret: string, status_token: string): string {\n    [token_info, derived_status] = SPLIT(status_token, '~')\n    info = decode_token_info(BASE64_DECODE(token_info))\n\n  statuses = CLONE(@status_table)\n  result = 'invalid'\n  while status = POP(statuses):\n    if HOTP(secret, DIV(NOW(:second), info[ttl]) + shift(status)) == derived_status\n            return status\n}\n")),(0,s.yg)("h3",{id:"43-example-implementation"},"4.3 Example implementation"),(0,s.yg)("p",null,"You can find an example implementation ",(0,s.yg)("a",{parentName:"p",href:"https://hexdocs.pm/boruta_ssi/0.1.0-beta.1/Boruta.VerifiableCredentials.Status.html"},"here"),"."),(0,s.yg)("h2",{id:"5-privacy-considerations"},"5. Privacy Considerations"),(0,s.yg)("h3",{id:"51-decentralized-architecture"},"5.1 Decentralized Architecture"),(0,s.yg)("p",null,"Status tokens are self-contained but only resolvable by the issuer which owns a secret component, the decentralized architecture gives a way to have low-weighted storage points. To state the validity of verifiable credentials and keep the holder's privacy, verifiers can resolve the status of the presented credentials without disclosing the data contained in it to the issuer in any manner. Mitigated by the fact that Time To Live information can give hints about the type of credential resolved."),(0,s.yg)("h3",{id:"52-status-table"},"5.2 Status table"),(0,s.yg)("p",null,"The status table represents the list of possible statuses that are encoded into a shift integer for lowering to a tiny list the issuer needed storage. The status list may be standardized globally or issuer-wide for the issuer emitted set of credentials to lower the verifiable credentials type disclosability. The status token being part of a credential and including a time to live, a way to check if statuses are hidden is to resolve it against a given status table whether the status token is valid to ensure a status is found. Otherwise, a hidden status has been set by the issuer. This check can be performed with a past timestamp, then, once issued there will always be a way to check if the status of a token has been hidden provided an issuer secret. Statuses may help categorize the annotated data. In order to do so, the element of the status table may be part of the same category."),(0,s.yg)("h3",{id:"53-granularity"},"5.3 Granularity"),(0,s.yg)("p",null,"Some verifiable credential formats support selective disclosure enabling to share part of the data contained in the verifiable credential payload without disclosing the remaining part. Status tokens can reference individual information or a set of disclosures. Taking the example of ",(0,s.yg)("a",{parentName:"p",href:"https://www.ietf.org/archive/id/draft-ietf-oauth-selective-disclosure-jwt-09.html"},"Selective Disclosure for JWTs"),", the status token can replace the suggested opaque salt to include the status information of the associated disclosure. The decentralization architecture of this suggested specification makes the status storage to be handled by the holders helping to reduce the weight of single-place storage."),(0,s.yg)("h3",{id:"54-annotation"},"5.4 Annotation"),(0,s.yg)("p",null,"By definition a status is an annotation on the data it denotes. Following this specification, the issuer is not limited for the statuses it set which may include statuses the holder may not be aware of. While this information is not disclosable, the issuer can hide statuses from the holder and the verifier which gives the ability to track them on verfication. When the verifier contacts the issuer to get the status, the latter has the ability to track the remote ip of the verifier making then the usage of the custom statuses trackable. This issue may be mitigated by reducing the possible statuses which may not be possible with the suggested algorithms or by making the status publicly readable for both the holder and the verifier."),(0,s.yg)("h3",{id:"55-issuer-trust"},"5.5 Issuer trust"),(0,s.yg)("p",null,"Status tokens are emitted by the issuer of the backed-up data. This issuer is the trust anchor of both the data and the status being the single source of truth of those information. The verifier is to trust the issuer providing a factor of trust for the holder delivered information. Here the suggested framework gives the ability to have that trust chain by directly resolving the status requesting the issuer which creates a direct link between both parties. That enforces trust through the DID document and the SSL abilities of the issuer domain, being again a single source of truth for trust of the data and the status giving all the required insurance to provide a service for the verifier. The link between the issuer and the verifier for trust is not herein anonymous, failing the privacy of the issuer but keeping the holder one which is the most important factor of decentralized identity beyond trust."),(0,s.yg)("h2",{id:"6-about-revocation"},"6. About revocation"),(0,s.yg)("p",null,"Considering the status as an annotation and that annotations prove the data and the data proves the annotations, seeing them as paradoxes, it is not possible to see revocation within the proposed framework for statuses. It would enforce to break one of the before statements proving the annotation is false and not yet to be considered. Then the revocation subject is quite an important subject to fix impairments. Those contain the identity information itself as a component and corrective actions in the annotation would fail the privacy brought by the decentralized identity concepts enforcing both the holder and the verifier to disclose identity information to the issuer."),(0,s.yg)("h2",{id:"7-going-further-status-chains"},"7. Going further, status chains"),(0,s.yg)("p",null,"It would be possible to store a list of statuses composing the status tokens one with the other. Composing the status tokens would result to a merkle tree. This would permit for an issuer to emit more than a single status but a list. The hash of HOTP values are to be taken at a single point of time providing the same hash format for all the emitted tokens. The verification would be made by rebuilding the composed tree, one status after the other keeping the same category building a merkle tree from result to result. The composition law for the given status tokens help to store more data staying in the same category."),(0,s.yg)("p",null,(0,s.yg)("img",{parentName:"p",src:"https://raw.githubusercontent.com/malach-it/vc-decentralized-status/main/images/status-chains.png",alt:"Status chains"})),(0,s.yg)("h3",{id:"71-choosing-a-status-among-the-chain"},"7.1 Choosing a status among the chain"),(0,s.yg)("p",null,"Apart from a single status token, the corresponding status list can be derived using a composition law, the status being a choice among the given list. This would enforce the issuer to provide the status list state at token emission. The pattern would not enforce the issuer to include the list associated to the token, but the contracted list must contain the status given by the associated token to provide the validity of the couple list / choice. Further discussions can be made for having choices that do not influence the resulting status token which is at first sight not possible with modern computing."),(0,s.yg)("p",null,(0,s.yg)("img",{parentName:"p",src:"https://raw.githubusercontent.com/malach-it/vc-decentralized-status/main/images/chosing-a-status-among-a-list.png",alt:"Couple list / choice"})),(0,s.yg)("h3",{id:"72-public-statuses"},"7.2 Public statuses"),(0,s.yg)("p",null,'An other way to see status would be to include the status list in the chain and publicly expose those statuses and the status list derivation, that would help to prevent from the hidden statuses issue. Then status tokens would be publicly solvable, the token being private. An example would be to have the statuses given, namely "valid", "suspended", "revoked" and have the signing did as secret.'),(0,s.yg)("h3",{id:"73-choosing-multiple-statuses"},"7.3 Choosing multiple statuses"),(0,s.yg)("p",null,"Using a binary sum as composition law, multiple statuses can be choosen from the given list. Giving them in their textual form along with the remaining sum of the other status tokens help to prove the statuses are part of the associated status list. This would also fix the hidden statuses issue. Computing the chosen status tokens sum and adding it to the rest results to the status list token. This would be a way to enable selective disclosure. It helps to selectively disclose status information without disclosing the number of statuses included in the token. Metaphoring the statuses as the verbal communication and the remaining sum as the non-verbal one."),(0,s.yg)("p",null,(0,s.yg)("img",{parentName:"p",src:"https://raw.githubusercontent.com/malach-it/vc-decentralized-status/main/images/choosing-multiple-statuses.png",alt:"Status sum"})),(0,s.yg)("p",null,"If the status list forms a coherent set, some disclosed subsets of that list can give meaningful information by themselves, choosing such a set would express information about the annotated data itself. That ability of such choice should be inherent to the coherence of the list and is not covered by this draft. It is probable that in modern computing only human can perform this."))}d.isMDXComponent=!0}}]);